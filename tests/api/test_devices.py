"""
Test cases for device management routes
"""
import pytest
import uuid
from unittest.mock import patch, MagicMock
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session

from app.models.audit_log import AuditLog
from app.models import Device, DeviceStatus, DeviceType,  Customer, User, Solution, DeviceSolution
from app.core.config import settings
from datetime import datetime
from botocore.exceptions import ClientError, NoCredentialsError
from app.schemas.device import DeviceBatchStatusRequest


# Test cases for device listing (GET /devices)
def test_get_all_devices_admin(client: TestClient, admin_token: str):
    """Test admin getting all devices"""
    response = client.get(
        f"{settings.API_V1_STR}/devices",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
    # Should return at least one device
    assert len(data) >= 1
    

def test_get_devices_by_customer_admin(client: TestClient, customer_admin_token: str, customer: Customer, device: Device):
    """Test getting devices filtered by customer_id"""
    response = client.get(
        f"{settings.API_V1_STR}/devices?customer_id={customer.customer_id}",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
    # All returned devices should belong to the specified customer
    for device_item in data:
        assert str(device_item["customer_id"]) == str(customer.customer_id)


def test_get_devices_customer_user_different_customer(client: TestClient, customer_admin_token: str, suspended_customer: Customer):
    """Test customer admin attempting to get devices from a different customer"""
    response = client.get(
        f"{settings.API_V1_STR}/devices?customer_id={suspended_customer.customer_id}",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response - should be forbidden
    assert response.status_code == 403
    data = response.json()
    assert "detail" in data
    assert "Not authorized" in data["detail"]


# Test cases for device creation (POST /devices)
def test_create_device_admin(client: TestClient, db: Session, admin_token: str, customer: Customer):
    """Test admin creating a new device"""
    device_data = {
        "description": "A test device",
        "mac_address": "00:11:22:33:44:56",
        "serial_number": "SN123456789",
        "device_type": "NVIDIA_JETSON",
        "firmware_version": "1.0.0",
        "location": "Test Location",
        "customer_id": str(customer.customer_id),
        "ip_address": "192.168.1.100"
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=device_data
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert "device_id" in data
    assert "name" in data  # Generated by the system
    assert data["mac_address"] == device_data["mac_address"]
    assert data["device_type"] == device_data["device_type"]
    assert str(data["customer_id"]) == device_data["customer_id"]
    
    # Verify device was created in database
    db.expire_all()
    created_device = db.query(Device).filter(Device.device_id == uuid.UUID(data["device_id"])).first()
    assert created_device is not None
    assert created_device.mac_address == device_data["mac_address"]
    
    # Verify audit log
    audit_log = db.query(AuditLog).filter(
        AuditLog.action_type == "DEVICE_CREATE",
        AuditLog.resource_id == str(created_device.device_id)
    ).first()
    assert audit_log is not None

def test_create_device_engineer(client: TestClient, engineer_token: str, customer: Customer):
    """Test engineer creating a new device"""
    device_data = {
        "description": "A test device created by engineer",
        "mac_address": "BB:BB:CC:DD:EE:FF",
        "serial_number": "SN987654321",
        "device_type": "RASPBERRY_PI",
        "firmware_version": "2.0.0",
        "location": "Engineer Location",
        "customer_id": str(customer.customer_id),
        "ip_address": "192.168.1.200"
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices",
        headers={"Authorization": f"Bearer {engineer_token}"},
        json=device_data
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert "device_id" in data
    assert data["mac_address"] == device_data["mac_address"]


def test_create_device_customer_user(client: TestClient, customer_admin_token: str, customer: Customer):
    """Test customer user attempting to create a device"""
    device_data = {
        "description": "A test device created by customer user",
        "mac_address": "12:22:33:44:55:66",
        "serial_number": "SNXXXXXXXX",
        "device_type": "NVIDIA_JETSON",
        "firmware_version": "1.0.0",
        "location": "User Location",
        "customer_id": str(customer.customer_id),
        "ip_address": "192.168.1.300"
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices",
        headers={"Authorization": f"Bearer {customer_admin_token}"},
        json=device_data
    )
    
    # Check response - should be forbidden
    assert response.status_code == 403
    data = response.json()
    assert "detail" in data
    assert "enough privileges" in data["detail"]

def test_create_device_duplicate_mac(client: TestClient, db: Session, admin_token: str, customer: Customer, device: Device):
    """Test creating a device with duplicate MAC address"""
    # Try to create another device with the same MAC address as an existing device
    duplicate_data = {
        "description": "Duplicate Device",
        "mac_address": device.mac_address,  # Use existing MAC address
        "serial_number": "SNDUPLICATE",
        "device_type": "NVIDIA_JETSON",
        "firmware_version": "1.0.0",
        "location": "Duplicate Location",
        "customer_id": str(customer.customer_id),
        "ip_address": "192.168.1.100"
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=duplicate_data
    )
    
    # Check response - should fail
    assert response.status_code == 400
    data = response.json()
    assert "detail" in data
    assert "already exists" in data["detail"]

def test_create_device_nonexistent_customer(client: TestClient, admin_token: str):
    """Test creating a device with non-existent customer"""
    nonexistent_id = uuid.uuid4()
    device_data = {
        "description": "A test device",
        "mac_address": "99:88:77:66:55:44",
        "serial_number": "SNABCDEF",
        "device_type": "RASPBERRY_PI",
        "firmware_version": "1.0.0",
        "location": "Nowhere",
        "customer_id": str(nonexistent_id),
        "ip_address": "192.168.1.100"
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=device_data
    )
    
    # Check response - should fail
    assert response.status_code == 404
    data = response.json()
    assert "detail" in data
    assert "Customer not found" in data["detail"]

# Test cases for getting a specific device (GET /devices/{device_id})
def test_get_device_by_id_admin(client: TestClient, admin_token: str, device: Device):
    """Test admin getting a device by ID"""
    response = client.get(
        f"{settings.API_V1_STR}/devices/{device.device_id}",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert str(data["device_id"]) == str(device.device_id)
    assert data["name"] == device.name
    assert data["mac_address"] == device.mac_address


def test_get_device_by_id_customer_user_own_customer(client: TestClient, customer_admin_token: str, device: Device):
    """Test customer user getting a device from their customer"""
    response = client.get(
        f"{settings.API_V1_STR}/devices/{device.device_id}",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert str(data["device_id"]) == str(device.device_id)

def test_get_device_by_id_customer_user_different_customer(client: TestClient, customer_admin_token: str, suspended_customer: Customer, admin_token: str):
    """Test customer user attempting to get a device from a different customer"""
    # First create a device for the suspended customer
    device_data = {
        "description": "A test device for a different customer",
        "mac_address": "DD:EE:FF:11:22:33",
        "serial_number": "SNDIFFERENT",
        "device_type": "NVIDIA_JETSON",
        "firmware_version": "1.0.0",
        "location": "Other Location",
        "customer_id": str(suspended_customer.customer_id),
        "ip_address": "192.168.1.250"
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=device_data
    )
    
    assert response.status_code == 200
    created_device = response.json()
    
    # Now get the device by ID as customer user
    response = client.get(
        f"{settings.API_V1_STR}/devices/{created_device['device_id']}",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response - should be forbidden
    assert response.status_code == 403
    data = response.json()
    assert "detail" in data
    assert "Not authorized" in data["detail"]

def test_get_nonexistent_device(client: TestClient, admin_token: str):
    """Test getting a non-existent device"""
    nonexistent_id = uuid.uuid4()
    response = client.get(
        f"{settings.API_V1_STR}/devices/{nonexistent_id}",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response - should not found
    assert response.status_code == 404
    data = response.json()
    assert "detail" in data
    assert "not found" in data["detail"]

# Test cases for updating a device (PUT /devices/{device_id})
def test_update_device_admin(client: TestClient, db: Session, admin_token: str, device: Device):
    """Test admin updating a device"""
    update_data = {
        "description": "Updated Description",
        "firmware_version": "2.0.0",
        "location": "Updated Location",
        "ip_address": "192.168.1.200"
    }
    
    response = client.put(
        f"{settings.API_V1_STR}/devices/{device.device_id}",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=update_data
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert data["description"] == update_data["description"]
    assert data["firmware_version"] == update_data["firmware_version"]
    assert data["location"] == update_data["location"]
    
    # Verify database updates
    db.expire_all()
    updated_device = db.query(Device).filter(Device.device_id == device.device_id).first()
    assert updated_device.description == update_data["description"]
    
    # Verify audit log
    audit_log = db.query(AuditLog).filter(
        AuditLog.action_type == "DEVICE_UPDATE",
        AuditLog.resource_id == str(device.device_id)
    ).first()
    assert audit_log is not None


def test_update_device_customer_admin(client: TestClient, customer_admin_token: str, device: Device):
    """Test customer admin updating a device from their customer"""
    update_data = {
        "description": "Customer Admin Updated",
        "firmware_version": "3.0.0",
        "location": "New Location"
    }
    
    response = client.put(
        f"{settings.API_V1_STR}/devices/{device.device_id}",
        headers={"Authorization": f"Bearer {customer_admin_token}"},
        json=update_data
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert data["description"] == update_data["description"]
    assert data["firmware_version"] == update_data["firmware_version"]
    assert data["location"] == update_data["location"]

# Test cases for provisioning a device (POST /devices/{device_id}/provision)
@patch('app.utils.aws_iot.iot_core.provision_device')
@patch('app.crud.device.device.update_cloud_info')
@patch('app.crud.customer.customer.get_by_id')
def test_provision_device(mock_get_customer, mock_update_cloud_info, mock_provision, 
                          client: TestClient, db: Session, admin_token: str, device: Device):
    """Test provisioning a device"""
    # Configure mocks
    customer_mock = MagicMock()
    customer_mock.iot_thing_group_name = "test_group"
    mock_get_customer.return_value = customer_mock
    
    mock_provision.return_value = {
        "thing_name": "test_thing",
        "thing_arn": "arn:aws:iot:region:account:thing/test_thing",
        "certificate_id": "cert_id",
        "certificate_arn": "arn:aws:iot:region:account:cert/cert_id",
        "certificate_path": "certificates/cert_id/cert_id.pem",
        "private_key_path": "certificates/cert_id/cert_id.key",
        "certificate_url": "https://example.com/cert.pem",
        "private_key_url": "https://example.com/key.pem"
    }
    
    mock_update_cloud_info.return_value = Device(
        device_id=device.device_id,
        name=device.name,
        customer_id=device.customer_id,
        device_type=device.device_type,
        thing_name="test_thing",
        thing_arn="arn:aws:iot:region:account:thing/test_thing",
        certificate_id="cert_id",
        certificate_arn="arn:aws:iot:region:account:cert/cert_id",
        certificate_path="certificates/cert_id/cert_id.pem",
        private_key_path="certificates/cert_id/cert_id.key",
        status=DeviceStatus.PROVISIONED
    )
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/{device.device_id}/provision",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert "device_id" in data
    assert "thing_name" in data
    assert "certificate_url" in data
    assert "private_key_url" in data
    
    # Verify the correct functions were called
    mock_provision.assert_called_once()
    mock_update_cloud_info.assert_called_once()

def test_provision_device_no_permission(client: TestClient, customer_admin_token: str, device: Device):
    """Test customer user attempting to provision a device (no permission)"""
    response = client.post(
        f"{settings.API_V1_STR}/devices/{device.device_id}/provision",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response - should be forbidden
    assert response.status_code == 403
    data = response.json()
    assert "detail" in data
    assert "enough privileges" in data["detail"]


@patch('app.crud.device.device.get_by_id')
def test_provision_already_provisioned_device(mock_get_by_id, client: TestClient, admin_token: str, active_device: Device):
    """Test provisioning an already provisioned device"""
    # Active device already has thing_name
    mock_get_by_id.return_value = active_device
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/{active_device.device_id}/provision",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response - should fail
    assert response.status_code == 400
    data = response.json()
    assert "detail" in data
    assert "already provisioned" in data["detail"]

# Test cases for decommissioning a device (POST /devices/{device_id}/decommission)
@patch('app.crud.device.device.decommission')
def test_decommission_device(mock_decommission, client: TestClient, db: Session, admin_token: str, active_device: Device):
    """Test decommissioning a device"""
    # Mock the database operation for decommissioning
    mock_decommission.return_value = Device(
        device_id=active_device.device_id,
        name=active_device.name,
        customer_id=active_device.customer_id,
        device_type=active_device.device_type,
        status=DeviceStatus.DECOMMISSIONED,
        is_online=False,                         
        created_at=datetime.now(),      
        updated_at=datetime.now()
    )
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/{active_device.device_id}/decommission",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "DECOMMISSIONED"
    
    # Verify function was called
    mock_decommission.assert_called_once()


def test_decommission_device_no_permission(client: TestClient, customer_admin_token: str, device: Device):
    """Test customer user attempting to decommission a device (no permission)"""
    response = client.post(
        f"{settings.API_V1_STR}/devices/{device.device_id}/decommission",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response - should be forbidden
    assert response.status_code == 403
    data = response.json()
    assert "detail" in data
    assert "enough privileges" in data["detail"]


# Test cases for activating a device (POST /devices/{device_id}/activate)
@patch('app.crud.device.device.activate')
def test_activate_device(mock_activate, client: TestClient, db: Session, admin_token: str, device: Device):
    """Test activating a device"""
    # Mock the database operation for activation
    mock_activate.return_value = Device(
        device_id=device.device_id,
        name=device.name,
        customer_id=device.customer_id,
        device_type=device.device_type,
        status=DeviceStatus.ACTIVE,
        is_online=True,                         
        created_at=datetime.now(),      
        updated_at=datetime.now()
    )
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/{device.device_id}/activate",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "ACTIVE"
    
    # Verify function was called
    mock_activate.assert_called_once()

def test_activate_device_no_permission(client: TestClient, customer_admin_token: str, device: Device):
    """Test customer user attempting to activate a device (no permission)"""
    response = client.post(
        f"{settings.API_V1_STR}/devices/{device.device_id}/activate",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response - should be forbidden
    assert response.status_code == 403
    data = response.json()
    assert "detail" in data
    assert "enough privileges" in data["detail"]


# Test delete device endpoint (DELETE /devices/{device_id})
@patch('app.utils.aws_iot.iot_core.delete_thing_certificate')
@patch('app.crud.device.device.remove')
def test_delete_device(mock_remove, mock_delete_thing, client: TestClient, db: Session, admin_token: str, active_device: Device):
    """Test deleting a device"""
    # Configure mocks
    mock_delete_thing.return_value = True
    mock_remove.return_value = Device(
        device_id=active_device.device_id,
        name=active_device.name,
        customer_id=active_device.customer_id,
        device_type=active_device.device_type,
        status=DeviceStatus.DECOMMISSIONED,
        is_online=True,                         
        created_at=datetime.now(),      
        updated_at=datetime.now()
    )
    
    response = client.delete(
        f"{settings.API_V1_STR}/devices/{active_device.device_id}",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    
    # Verify functions were called
    mock_remove.assert_called_once()

def test_delete_device_no_permission(client: TestClient, customer_admin_token: str, device: Device):
    """Test customer user attempting to delete a device (no permission)"""
    response = client.delete(
        f"{settings.API_V1_STR}/devices/{device.device_id}",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response - should be forbidden
    assert response.status_code == 403
    data = response.json()
    assert "detail" in data
    assert "enough privileges" in data["detail"]

def test_delete_nonexistent_device(client: TestClient, admin_token: str):
    """Test deleting a non-existent device"""
    nonexistent_id = uuid.uuid4()
    response = client.delete(
        f"{settings.API_V1_STR}/devices/{nonexistent_id}",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response - should not found
    assert response.status_code == 404
    data = response.json()
    assert "detail" in data
    assert "not found" in data["detail"]

def test_get_compatible_devices_for_solution_by_customer_all(client: TestClient, admin_token: str, customer: Customer, solution: Solution):
    """Test getting all devices compatible with a solution for a customer"""
    # First, get a solution from the database
    response = client.get(
        f"{settings.API_V1_STR}/devices/compatible/solution/{solution.solution_id}/customer/{customer.customer_id}?available_only=false",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
    
    # Verify that all returned devices belong to the customer and are compatible with the solution
    for device_item in data:
        assert str(device_item["customer_id"]) == str(customer.customer_id)
        # Verify device type is in solution's compatibility list
        assert device_item["device_type"] in solution.compatibility

def test_get_compatible_devices_for_solution_by_customer_available_only(client: TestClient, admin_token: str, customer: Customer, solution: Solution):
    """Test getting only available devices compatible with a solution for a customer"""
    response = client.get(
        f"{settings.API_V1_STR}/devices/compatible/solution/{solution.solution_id}/customer/{customer.customer_id}?available_only=true",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
    
    # Now use a separate API call to verify these devices don't have solutions deployed
    # This tests the endpoint's behavior rather than directly accessing the DB
    for device_item in data:
        device_id = device_item["device_id"]
        device_solutions_response = client.get(
            f"{settings.API_V1_STR}/device-solutions/device/{device_id}",
            headers={"Authorization": f"Bearer {admin_token}"}
        )
        assert device_solutions_response.status_code == 200
        device_solutions = device_solutions_response.json()
        assert len(device_solutions) == 0
    
def test_get_compatible_devices_for_solution_by_customer_as_customer_admin(client: TestClient, customer_admin_token: str, customer_admin_user: User, solution: Solution):
    """Test customer user getting devices compatible with a solution for their customer"""
    response = client.get(
        f"{settings.API_V1_STR}/devices/compatible/solution/{solution.solution_id}/customer/{customer_admin_user.customer_id}",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
    
    # All devices should belong to the user's customer
    for device_item in data:
        assert str(device_item["customer_id"]) == str(customer_admin_user.customer_id)


def test_get_compatible_devices_for_solution_by_customer_unauthorized(client: TestClient, customer_admin_token: str, suspended_customer: Customer, solution: Solution):
    """Test customer user attempting to get devices for a different customer"""
    response = client.get(
        f"{settings.API_V1_STR}/devices/compatible/solution/{solution.solution_id}/customer/{suspended_customer.customer_id}",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response - should be forbidden
    assert response.status_code == 403
    data = response.json()
    assert "detail" in data
    assert "Not authorized" in data["detail"]

def test_get_compatible_devices_nonexistent_solution(client: TestClient, admin_token: str, customer: Customer):
    """Test getting devices with non-existent solution"""
    nonexistent_id = uuid.uuid4()
    response = client.get(
        f"{settings.API_V1_STR}/devices/compatible/solution/{nonexistent_id}/customer/{customer.customer_id}",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response - should not found
    assert response.status_code == 404
    data = response.json()
    assert "detail" in data
    assert "Solution not found" in data["detail"]

def test_get_compatible_devices_nonexistent_customer(client: TestClient, admin_token: str, solution: Solution):
    """Test getting devices with non-existent customer"""
    nonexistent_id = uuid.uuid4()
    response = client.get(
        f"{settings.API_V1_STR}/devices/compatible/solution/{solution.solution_id}/customer/{nonexistent_id}",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response - should not found
    assert response.status_code == 404
    data = response.json()
    assert "detail" in data
    assert "Customer not found" in data["detail"]

# =============================================================================
# Test cases for batch device status (POST /devices/batch-status)
# =============================================================================

def test_get_batch_device_status_admin(client: TestClient, admin_token: str, device: Device, active_device: Device):
    """Test admin getting batch device status"""
    batch_request = {
        "device_ids": [str(device.device_id), str(active_device.device_id)]
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/batch-status",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=batch_request
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, dict)
    assert str(device.device_id) in data
    assert str(active_device.device_id) in data
    
    # Check device status structure
    device_status = data[str(device.device_id)]
    assert "device_id" in device_status
    assert "device_name" in device_status
    assert "is_online" in device_status
    assert device_status["device_name"] == device.name


def test_get_batch_device_status_customer_admin_own_devices(client: TestClient, customer_admin_token: str, device: Device):
    """Test customer admin getting status for their own devices"""
    batch_request = {
        "device_ids": [str(device.device_id)]
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/batch-status",
        headers={"Authorization": f"Bearer {customer_admin_token}"},
        json=batch_request
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert str(device.device_id) in data
    device_status = data[str(device.device_id)]
    assert device_status["device_name"] == device.name
    assert "is_online" in device_status


def test_get_batch_device_status_mixed_valid_invalid_devices(client: TestClient, admin_token: str, device: Device):
    """Test batch status with mix of valid and invalid device IDs"""
    invalid_device_id = str(uuid.uuid4())
    
    batch_request = {
        "device_ids": [str(device.device_id), invalid_device_id]
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/batch-status",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=batch_request
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    
    # Valid device should have normal status
    assert str(device.device_id) in data
    valid_status = data[str(device.device_id)]
    assert valid_status["device_name"] == device.name
    assert "error" not in valid_status or valid_status["error"] is None
    
    # Invalid device should have error
    assert invalid_device_id in data
    invalid_status = data[invalid_device_id]
    assert invalid_status["error"] == "Device not found"
    assert invalid_status["device_name"] == "Unknown"


def test_get_batch_device_status_empty_device_list(client: TestClient, admin_token: str):
    """Test batch status with empty device list"""
    batch_request = {
        "device_ids": []
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/batch-status",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=batch_request
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, dict)
    assert len(data) == 0


@patch('app.api.routes.devices.iot_command_service.get_device_shadow')
def test_get_batch_device_status_with_shadow_data(
    mock_get_shadow, client: TestClient, admin_token: str, active_device: Device
):
    """Test batch status with AWS IoT shadow data"""
    # Mock shadow response for online device
    mock_get_shadow.return_value = {
        "state": {
            "reported": {
                "applicationStatus": {
                    "status": "online",
                    "timestamp": "2025-01-01T00:00:00Z"
                }
            }
        }
    }
    
    batch_request = {
        "device_ids": [str(active_device.device_id)]
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/batch-status",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=batch_request
    )
    
    # Check response
    assert response.status_code == 200
    data = response.json()
    device_status = data[str(active_device.device_id)]
    assert device_status["is_online"] == True


def test_get_batch_device_status_unauthorized(client: TestClient, device: Device):
    """Test batch status without authentication"""
    batch_request = {
        "device_ids": [str(device.device_id)]
    }
    
    response = client.post(
        f"{settings.API_V1_STR}/devices/batch-status",
        json=batch_request
    )
    
    # Check response - should be unauthorized
    assert response.status_code == 401


# =============================================================================
# Test cases for device image retrieval (GET /devices/{device_id}/image)
# =============================================================================

@patch('app.api.routes.devices.boto3.client')
def test_get_device_image_admin(mock_boto_client, client: TestClient, admin_token: str, active_device: Device):
    """Test admin getting device image"""
    # Mock S3 client and response
    mock_s3 = MagicMock()
    mock_boto_client.return_value = mock_s3
    
    # Mock successful S3 response
    mock_response = {
        'Body': MagicMock(),
        'ContentType': 'image/jpeg'
    }
    mock_response['Body'].read.return_value = b'fake_image_data'
    mock_s3.get_object.return_value = mock_response
    
    response = client.get(
        f"{settings.API_V1_STR}/devices/{active_device.device_id}/image?solution=City Eye",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    assert response.headers["content-type"] == "image/jpeg"
    assert "no-cache" in response.headers["cache-control"]
    assert response.content == b'fake_image_data'
    
    # Verify S3 call
    mock_s3.get_object.assert_called_once_with(
        Bucket="cc-captured-images",
        Key=f"captures/City Eye/{active_device.name}/capture.jpg"
    )


@patch('app.api.routes.devices.boto3.client')
def test_get_device_image_customer_admin_own_device(
    mock_boto_client, client: TestClient, customer_admin_token: str, active_device: Device
):
    """Test customer admin getting image for their own device"""
    # Mock S3 client
    mock_s3 = MagicMock()
    mock_boto_client.return_value = mock_s3
    
    mock_response = {
        'Body': MagicMock(),
        'ContentType': 'image/jpeg'
    }
    mock_response['Body'].read.return_value = b'customer_device_image'
    mock_s3.get_object.return_value = mock_response
    
    response = client.get(
        f"{settings.API_V1_STR}/devices/{active_device.device_id}/image?solution=City Eye",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response
    assert response.status_code == 200
    assert response.content == b'customer_device_image'


def test_get_device_image_customer_admin_unauthorized(
    client: TestClient, customer_admin_token: str, suspended_customer: Customer, admin_token: str
):
    """Test customer admin attempting to get image for device from different customer"""
    # Create device for different customer
    device_data = {
        "description": "Device for different customer",
        "mac_address": "FF:EE:DD:CC:BB:AA",
        "serial_number": "SN888888888",
        "device_type": "NVIDIA_JETSON",
        "customer_id": str(suspended_customer.customer_id),
        "status": "ACTIVE"
    }
    
    device_response = client.post(
        f"{settings.API_V1_STR}/devices",
        headers={"Authorization": f"Bearer {admin_token}"},
        json=device_data
    )
    other_device = device_response.json()
    
    response = client.get(
        f"{settings.API_V1_STR}/devices/{other_device['device_id']}/image?solution=City Eye",
        headers={"Authorization": f"Bearer {customer_admin_token}"}
    )
    
    # Check response - should be forbidden
    assert response.status_code == 403
    data = response.json()
    assert "detail" in data
    assert "Not authorized" in data["detail"]


def test_get_device_image_device_not_found(client: TestClient, admin_token: str):
    """Test getting image for non-existent device"""
    nonexistent_id = uuid.uuid4()
    
    response = client.get(
        f"{settings.API_V1_STR}/devices/{nonexistent_id}/image?solution=City Eye",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response - should be not found
    assert response.status_code == 404
    data = response.json()
    assert "detail" in data
    assert "Device not found" in data["detail"]


@patch('app.crud.device.device.get_by_id')
def test_get_device_image_device_inactive_mocked(mock_get_device, client: TestClient, admin_token: str, device: Device):
    """Test getting image for inactive device using mocked device status"""
    # Create a mock device with inactive status
    mock_inactive_device = MagicMock()
    mock_inactive_device.device_id = device.device_id
    mock_inactive_device.customer_id = device.customer_id
    mock_inactive_device.name = device.name
    mock_inactive_device.status = DeviceStatus.CREATED  # or INACTIVE, SUSPENDED, etc.
    
    mock_get_device.return_value = mock_inactive_device
    
    response = client.get(
        f"{settings.API_V1_STR}/devices/{device.device_id}/image?solution=City Eye",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response - should fail because device is not active
    assert response.status_code == 400
    data = response.json()
    assert "detail" in data
    assert "not active" in data["detail"]


@patch('app.api.routes.devices.boto3.client')
def test_get_device_image_aws_credentials_error(mock_boto_client, client: TestClient, admin_token: str, active_device: Device):
    """Test getting image when AWS credentials are not configured"""
    # Mock S3 client to raise NoCredentialsError
    mock_boto_client.side_effect = NoCredentialsError()
    
    response = client.get(
        f"{settings.API_V1_STR}/devices/{active_device.device_id}/image?solution=City Eye",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response - should be server error
    assert response.status_code == 500
    data = response.json()
    assert "detail" in data
    assert "credentials not configured" in data["detail"]


def test_get_device_image_unauthorized(client: TestClient, active_device: Device):
    """Test getting device image without authentication"""
    response = client.get(
        f"{settings.API_V1_STR}/devices/{active_device.device_id}/image?solution=City Eye"
    )
    
    # Check response - should be unauthorized
    assert response.status_code == 401


def test_get_device_image_missing_solution_parameter(client: TestClient, admin_token: str, active_device: Device):
    """Test getting device image without solution parameter"""
    response = client.get(
        f"{settings.API_V1_STR}/devices/{active_device.device_id}/image",
        headers={"Authorization": f"Bearer {admin_token}"}
    )
    
    # Check response - should be validation error
    assert response.status_code == 422
    data = response.json()
    assert "detail" in data